#!/usr/bin/env python3
import numpy as np
import argparse
import os
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'lib'))

import common
import resultserializer
import clustermaker
import inputparser

import json
import util
import plotutil

def write_header(runid, outf):
  print('<meta charset="utf-8">', file=outf)
  print('<script src="https://d3js.org/d3.v5.min.js"></script>', file=outf)
  for jsfn in ('tree_plotter.js', 'posterior_summ.js'):
    print('<script type="text/javascript">%s</script>' % plotutil.read_file(jsfn), file=outf)
  print('<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">', file=outf)
  print('<style type="text/css">%s</style>' % plotutil.read_file('tree.css'), file=outf)
  if runid is not None:
    print('<h1>%s</h1>' % runid, file=outf)

def summarize(runid, results, params, supervars, html_out_fn):
  N = len(results['prob'])
  assert np.array_equal(np.argsort(-results['prob'], kind='stable'), np.arange(N))

  _make_struct = lambda tidx: util.make_tree_struct(
    results['struct'][tidx],
    results['count'][tidx],
    results['llh'][tidx],
    results['prob'][tidx],
    results['phi'][tidx],
    supervars,
    params['samples'],
  )

  limit = 20
  structs = [_make_struct(tidx) for tidx in range(min(N, limit))]
  json_trees = {
    'structs': structs,
  }

  with open(html_out_fn, 'w') as outf:
    write_header(runid, outf)
    print("<script type=\"text/javascript\">var tree_json = '%s'; var results = JSON.parse(tree_json);</script>" % json.dumps(structs), file=outf)
    print('<h2>Trees</h2>', file=outf)
    print('<ul><li>Number of unique trees: %s</li></ul>' % N, file=outf)
    print('<table id="trees" class="table table-striped"><thead><tr><th>Index</th><th>Posterior</th><th>nLgLh</th><th>Count</th><th>Structure</th></tr></thead><tbody class="container"></tbody></table>', file=outf)
    print(plotutil.js_on_load("(new PosteriorSumm()).plot(results, '#trees .container');"), file=outf)

def _make_congraph(results):
  adjms = np.array([util.convert_parents_to_adjmatrix(struct) for struct in results['struct']])
  weights = results['prob']
  assert len(weights) == len(adjms)
  assert np.isclose(1, np.sum(weights))
  graph = np.sum(weights[:,np.newaxis,np.newaxis] * adjms, axis=0)
  np.fill_diagonal(graph, 0)

  parent_sum = np.sum(graph, axis=0)
  assert parent_sum[0] == 0 and np.allclose(1, parent_sum[1:])
  assert np.all(0 <= graph) and np.all(graph <= 1)
  return graph

def _render_congraph(congraph, threshold=0.05):
  root = 0
  stack = [root]
  maxwt = 5

  visited = set()
  G = 'digraph {\n'

  while len(stack) > 0:
    node = stack.pop()
    if node in visited:
      continue
    visited.add(node)
    children = np.flatnonzero(congraph[node] >= threshold).tolist()
    for child in children:
      G += '%s -> %s [penwidth=%s]\n' % (
        node,
        child,
        maxwt * congraph[node,child]
      )
    stack += children
  G += '}'
  return G

def main():
  parser = argparse.ArgumentParser(
    description='LOL HI THERE',
    formatter_class=argparse.ArgumentDefaultsHelpFormatter
  )
  parser.add_argument('--runid')
  parser.add_argument('--dot', dest='dot_fn')
  parser.add_argument('ssm_fn')
  parser.add_argument('params_fn')
  parser.add_argument('results_fn')
  parser.add_argument('html_out_fn')
  args = parser.parse_args()

  results = resultserializer.load(args.results_fn)
  variants = inputparser.load_ssms(args.ssm_fn)
  params = inputparser.load_params(args.params_fn)
  supervars = clustermaker.make_cluster_supervars(results['clusters'], variants)
  supervars = [supervars[vid] for vid in common.sort_vids(supervars.keys())]

  summarize(args.runid, results, params, supervars, args.html_out_fn)
  if args.dot_fn is not None:
    congraph = _make_congraph(results)
    congraph_dot = _render_congraph(congraph)
    with open(args.dot_fn, 'w') as F:
      print(congraph_dot, file=F)

if __name__ == '__main__':
  main()
