#!/usr/bin/env python3
import argparse
import os
import sys

sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'lib'))
import common
import resultserializer
import clustermaker
import inputparser
import numpy as np

import vaf_plotter
import relation_plotter
import json
import util
import plotutil

def _calc_eta(struct, phi):
  K, M = phi.shape
  assert len(struct) == K - 1
  adj = util.convert_parents_to_adjmatrix(struct)
  Z = util.make_ancestral_from_adj(adj)
  Z_inv = np.linalg.inv(Z)
  eta = np.dot(Z_inv, phi)
  return eta

def _plot_eta(struct, phi, sampnames, outf):
  # Avoid Plotly dependency unless user wants this plot.
  import plotly.graph_objs as go
  import plotly.io as pio

  eta = _calc_eta(struct, phi)
  traces = [go.Bar(
    name = 'Pop. %s' % cidx,
    x = sampnames,
    y = row,
    text = ['Population %s: %.0f%%' % (cidx, 100*E) for E in row],
    hoverinfo = 'x+text',
    width = 0.9,
  ) for cidx, row in enumerate(eta)]
  layout = go.Layout(
    barmode = 'stack',
    bargap = 0.1,
    template = 'seaborn',
    xaxis = {'title': 'Sample'},
    yaxis = {
      'title': 'Population frequency',
      'tickformat': ',.0%',
    },
  )
  fig = go.Figure(data=traces, layout=layout)
  plot_html = pio.to_html(fig, include_plotlyjs='cdn')
  print('<h2>Population frequencies</h2>%s' % plot_html, file=outf)

def _write_tree_json(tree_struct, jsonfn):
  with open(jsonfn, 'w') as F:
    print(json.dumps(tree_struct), file=F)

def write_header(runid, outf):
  print('<meta charset="utf-8">', file=outf)
  print('<script src="https://d3js.org/d3.v5.min.js"></script>', file=outf)
  for jsfn in ('highlight_table_labels.js', 'tree_plotter.js'):
    print('<script type="text/javascript">%s</script>' % plotutil.read_file(jsfn), file=outf)
  print('<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">', file=outf)
  for cssfn in ('tree.css', 'matrix.css'):
    print('<style type="text/css">%s</style>' % plotutil.read_file(cssfn), file=outf)
  print('<style type="text/css">.container { margin: 30px; } td, th, table { padding: 5px; margin: 0; border-collapse: collapse; font-weight: normal; } span { visibility: hidden; } td:hover > span { visibility: visible; } .highlighted { background-color: black !important; color: white; }</style>', file=outf)
  if runid is not None:
    print('<h1>%s</h1>' % runid, file=outf)

def _write_tree_html(tree_struct, plot_phi, plot_phi_hat, plot_phi_error, plot_phi_interleaved, outf):
  print("<script type=\"text/javascript\">var tree_json = '%s'; var results = JSON.parse(tree_json);</script>" % json.dumps(tree_struct), file=outf)

  print('''
  <div id="trees" class="container"><h2>Tree</h2></div>
  %s
  ''' % plotutil.js_on_load('''var container = '#trees'; d3.select(container).append('h3').text('nlglh=' + results.nlglh.toFixed(3) + ' prob=' + results.prob.toFixed(3)); (new TreePlotter()).plot(0, results.parents, results.phi,  results.samples, container);'''), file=outf)

  if plot_phi:
    print('''
    <div id="phi_matrix" class="container"><h2>Tree-constrained lineage frequencies</h2></div>
    %s
    ''' % plotutil.js_on_load('''(new PhiMatrix()).plot(results.phi, results.samples, '#phi_matrix');'''), file=outf)

  if plot_phi_hat:
    print('''
    <div id="phi_hat_matrix" class="container"><h2>Data-implied lineage frequencies</h2></div>
    %s
    ''' % plotutil.js_on_load('''(new PhiMatrix().plot(results.phi_hat, results.samples, '#phi_hat_matrix'));'''), file=outf)

  if plot_phi_error:
    print('''
    <div id="phi_error_matrix" class="container"><h2>Lineage frequency error</h2></div>
    %s
    ''' % plotutil.js_on_load('''(new PhiErrorMatrix()).plot(results.phi, results.phi_hat, results.samples, '#phi_error_matrix');'''), file=outf)

  if plot_phi_interleaved:
    print('''
    <div id="phi_interleaved_matrix" class="container"><h2>Interleaved lineage frequencies</h2></div>
    %s
    ''' % plotutil.js_on_load('''(new PhiInterleavedMatrix()).plot(results.phi, results.phi_hat, results.samples, '#phi_interleaved_matrix');'''), file=outf)

def write_cluster_stats(clusters, garbage, supervars, variants, outf):
  cluster_dev = []
  for C, S in zip(clusters, supervars):
    S_freq = S['vaf'] / (2*S['omega_v'])[None,:] # 1xS
    cluster_freq = np.array([variants[V]['vaf'] / (2*variants[V]['omega_v']) for V in C]) # |C|xS
    absdev = np.abs(cluster_freq - S_freq)
    cluster_dev.append(np.median(absdev))

  rows = [(cidx + 1, len(C), '%.3f' % cdev) for cidx, (C, cdev) in enumerate(zip(clusters, cluster_dev))]
  rows.append(('Garbage', len(garbage), None))
  rows.append(('Total', np.sum([len(C) for C in clusters]), None))

  print('<h2>Cluster stats</h2>', file=outf)
  print('<table class="table table-striped table-hover">', file=outf)
  print('<thead><tr><th>Cluster</th><th>Members</th><th>Deviation</th></tr></thead><tbody>', file=outf)
  for row in rows:
    rowhtml = ''.join(['<td>%s</td>' % (V if V is not None else '&mdash;') for V in row])
    print('<tr>%s</tr>' % rowhtml, file=outf)
  print('</tbody></table>', file=outf)

def _choose_plots(to_plot, to_omit, all_choices):
  if to_plot is None:
    plot_choices = set(all_choices)
  else:
    plot_choices = set(to_plot)

  if to_omit is not None:
    plot_choices -= set(to_omit)

  # If we want to plot any of the phi matrices, we need to also plot the
  # tree, so that the relevant data structures are generated below. This is
  # silly, so I should fix it eventually -- we should be able to plot just
  # the phis if we want.
  if len(set(('phi', 'phi_hat', 'phi_error', 'phi_interleaved')) & plot_choices) > 0:
    plot_choices.add('tree')

  return plot_choices

def main():
  all_plot_choices = (
    'tree',
    'pairwise_separate',
    'pairwise_mle',
    'vaf_matrix',
    'phi',
    'phi_hat',
    'phi_error',
    'phi_interleaved',
    'cluster_stats',
    'eta',
  )
  parser = argparse.ArgumentParser(
    description='LOL HI THERE',
    formatter_class=argparse.ArgumentDefaultsHelpFormatter
  )
  parser.add_argument('--tree-index', type=int, default=0)
  parser.add_argument('--plot', dest='plot_choices', nargs='+', choices=all_plot_choices,
    help='Things to plot; by default, plot everything')
  parser.add_argument('--omit-plots', dest='omit_plots', nargs='+', choices=all_plot_choices,
    help='Things to omit from plotting; overrides --plot')
  parser.add_argument('--runid')
  parser.add_argument('--tree-json', dest='tree_json_fn',
    help='Additional external file in which to store JSON, which is already stored statically in the HTML file')
  parser.add_argument('ssm_fn')
  parser.add_argument('params_fn')
  parser.add_argument('results_fn')
  parser.add_argument('html_out_fn')
  args = parser.parse_args()

  plot_choices = _choose_plots(args.plot_choices, args.omit_plots, all_plot_choices)

  results = resultserializer.Results(args.results_fn)
  variants = inputparser.load_ssms(args.ssm_fn)
  params = inputparser.load_params(args.params_fn)
  supervars = clustermaker.make_cluster_supervars(results.get('clusters'), variants)
  supervars = [supervars[vid] for vid in common.sort_vids(supervars.keys())]
  tidx = args.tree_index

  with open(args.html_out_fn, 'w') as outf:
    write_header(args.runid, outf)

    if 'tree' in plot_choices:
      tree_struct = util.make_tree_struct(
        results.get('struct')[tidx],
        results.get('count')[tidx],
        results.get('llh')[tidx],
        results.get('prob')[tidx],
        results.get('phi')[tidx],
        supervars,
        params['samples'],
      )
      _write_tree_html(
        tree_struct,
        'phi' in plot_choices,
        'phi_hat' in plot_choices,
        'phi_error' in plot_choices,
        'phi_interleaved' in plot_choices,
        outf,
      )
      if args.tree_json_fn is not None:
        _write_tree_json(tree_struct, args.tree_json_fn)

    if 'eta' in plot_choices:
      _plot_eta(results.get('struct')[tidx], results.get('phi')[tidx], params['samples'], outf)

    if 'vaf_matrix' in plot_choices:
      vaf_plotter.plot_vaf_matrix(
        results.get('clusters'),
        variants,
        supervars,
        results.get('garbage'),
        results.get('phi')[tidx] if results.has('phi') else None,
        params['samples'],
        should_correct_vaf=True,
        outf=outf,
      )

    if 'pairwise_mle' in plot_choices:
      relation_plotter.plot_ml_relations(results.get_mutrel('clustrel_posterior'), outf)
    if 'pairwise_separate' in plot_choices:
      relation_plotter.plot_separate_relations(results.get_mutrel('clustrel_posterior'), outf)
    if 'cluster_stats' in plot_choices:
      write_cluster_stats(results.get('clusters'), results.get('garbage'), supervars, variants, outf)

if __name__ == '__main__':
  main()
